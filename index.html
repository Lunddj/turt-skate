<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Turtle Skater — Restored Stable Build</title>
  <style>
    :root { color-scheme: light dark; }
    body { margin:0; background:#a8d8ff; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; display:grid; place-items:center; height:100svh; overflow:hidden; }
    .wrap { width: min(900px, 95vw); position: relative; }
    canvas { width: 100%; height: 320px; display:block; border-radius:14px; box-shadow:0 10px 30px rgba(0,0,0,.15); touch-action: manipulation; }
    .menu { position:absolute; inset:0; display:grid; place-items:center; padding:16px; pointer-events:auto; }
    .card { width:min(560px,92%); border-radius:16px; padding:20px 22px; text-align:center; background:linear-gradient(135deg, rgba(255,255,255,.78), rgba(255,255,255,.55)); box-shadow:0 18px 40px rgba(0,0,0,.22); backdrop-filter: blur(8px) saturate(130%); border:1px solid rgba(0,0,0,.08); }
    .title { font-size: clamp(22px, 5vw, 36px); margin: 2px 0 8px; color:#063 }
    .subtitle { margin: 0 0 16px; color:#075; opacity:.85 }
    .controls { font-size: 14px; color:#064; opacity:.85; margin-top:10px }
    .controls kbd { padding:.15rem .35rem; border-radius:6px; border:1px solid #0003; background:#fff6 }
    .cta { margin-top: 12px; display:flex; gap:10px; justify-content:center; flex-wrap:wrap }
    button.start { font: inherit; font-weight: 700; border-radius: 12px; padding: 10px 16px; cursor:pointer; background:#0a8f66; color:white; border: none; box-shadow: 0 6px 16px rgba(10,143,102,.35); }
    button.start:active { transform: translateY(1px); }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="game" width="900" height="320" aria-label="Turtle skating down a city street"></canvas>

    <!-- Title Screen -->
    <div id="menu" class="menu" aria-live="polite">
      <div class="card">
        <div class="title">Turtle Skater</div>
        <div class="subtitle">Jump boxes & cars. Clean jumps speed you up; crashes slow you down.</div>
        <div class="cta"><button id="startBtn" class="start" aria-label="Start game">Start</button></div>
        <div class="controls">Jump: <kbd>Space</kbd> or <kbd>Tap/Click</kbd> · Day↔Night every 30s</div>
      </div>
    </div>

    <!-- Game Over Screen -->
    <div id="gameOver" class="menu" style="display:none" aria-live="polite">
      <div class="card">
        <div class="title">Game Over</div>
        <div class="subtitle">Score: <span id="finalScore">0</span></div>
        <div class="cta"><button id="restartBtn" class="start" aria-label="Restart game">Restart</button></div>
        <div class="controls">Press <kbd>Enter</kbd> or click <kbd>Restart</kbd></div>
      </div>
    </div>
  </div>

  <script>
  (function(){
    // ===== Canvas setup =====
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const menu = document.getElementById('menu');
    const startBtn = document.getElementById('startBtn');
    const gameOverEl = document.getElementById('gameOver');
    const restartBtn = document.getElementById('restartBtn');
    const finalScoreEl = document.getElementById('finalScore');

    let DPR = Math.max(1, Math.min(window.devicePixelRatio || 1, 2));
    function resize(){ const cssW = canvas.clientWidth, cssH = canvas.clientHeight; DPR = Math.max(1, Math.min(window.devicePixelRatio||1, 2)); canvas.width = Math.round(cssW*DPR); canvas.height = Math.round(cssH*DPR);} 
    window.addEventListener('resize', resize, {passive:true}); resize();

    // ===== Utilities =====
    const W = ()=>canvas.width, H=()=>canvas.height, snap=(n)=>Math.round(n);
    const lerp = (a,b,t)=>a+(b-a)*t;
    function mixColor(c1,c2,t){ const a=[parseInt(c1.substr(1,2),16),parseInt(c1.substr(3,2),16),parseInt(c1.substr(5,2),16)]; const b=[parseInt(c2.substr(1,2),16),parseInt(c2.substr(3,2),16),parseInt(c2.substr(5,2),16)]; const m=a.map((v,i)=>Math.round(lerp(v,b[i],t))); return `rgb(${m[0]}, ${m[1]}, ${m[2]})`; }
    function mulberry32(a){ return function(){ let t = a += 0x6D2B79F5; t = Math.imul(t ^ t>>>15, t|1); t ^= t + Math.imul(t ^ t>>>7, t|61); return ((t ^ t>>>14)>>>0)/4294967296; } }
    function hash(n){ const x=Math.sin(n*12.9898)*43758.5453; return x-Math.floor(x); }

    // ===== World constants & state =====
    const groundY = ()=>Math.round(H()*0.78);
    const roadH = ()=>Math.round(H()*0.28);
    const DAY_NIGHT_PERIOD = 30000; // ms day->night->day (~30s) // ms day->night->day

    let rng = mulberry32((Date.now() ^ (Math.random()*1e9|0))>>>0);

    let gameState = 'menu'; // 'menu' | 'playing' | 'gameover'
    let last = 0, tClockStart = 0;

    // Speed & score
    const baseSpeed = 0.28; // canvas units per ms baseline (scaled by width)
    let startSpeed=0, minSpeed=0, maxSpeed=0, speed=0; // runtime
    function clampSpeed(v){ return Math.max(minSpeed, Math.min(maxSpeed, v)); }
    let spawnTimer=0, nextSpawnIn=400; // obstacle spawn control
    let score = 0; function updateScore(){}
    let cleanJumps = 0;
    let floaters = []; // transient "+X" texts over the turtle on clean jumps
    let multTierVis = 1, multAlpha = 0, multAlphaTarget = 0;
    let crashedFlashTimer = 0;

    // Health
    const maxHearts=5; let hearts=maxHearts;

    // Player
    const turtle = { x:()=>Math.round(W()*0.18), y:0, vy:0, r:()=>Math.round(H()*0.055), onGround:true, jump(){ if(!this.onGround) return; const base = H()*0.038; this.vy = base + speed*0.09; this.onGround=false; } };

    // Background distances (parallax, continuous)
    const laneDist=[0,0,0]; let nbDist=0, fenceDist=0, dashDist=0;

    // Obstacles & pickups
    const OBST = { BOX:'box', CAR:'car' };
    let obstacles=[];
    let heartPickups=[], heartSpawnTimer=0, nextHeartIn=0;
    let coinPickups=[], coinSpawnTimer=0, nextCoinIn=0;

    // Schedulers
    function scheduleNextHeart(){ nextHeartIn = 8000 + rng()*7000; }
    function scheduleNextCoin(){ nextCoinIn  = 3000 + rng()*6000; }

    function reseed(){ rng = mulberry32((Date.now() ^ (Math.random()*1e9|0))>>>0); }

    // ===== UI Flow =====
    function begin(){ if(gameState==='playing') return; gameState='playing'; menu.style.display='none'; gameOverEl.style.display='none'; const now=performance.now(); if(!tClockStart) tClockStart=now; startRun(now); }
    function restart(){ gameState='playing'; gameOverEl.style.display='none'; const now=performance.now(); startRun(now); }
    startBtn.addEventListener('click', begin);
    restartBtn.addEventListener('click', restart);
    window.addEventListener('keydown', (e)=>{
      if(gameState==='menu' && (e.code==='Space'||e.code==='Enter') && !e.repeat){ e.preventDefault(); begin(); return; }
      if(gameState==='gameover' && (e.code==='Space'||e.code==='Enter') && !e.repeat){ e.preventDefault(); restart(); return; }
      if(gameState==='playing' && (e.code==='Space'||e.key===' ') && !e.repeat){ e.preventDefault(); turtle.jump(); }
    });
    canvas.addEventListener('pointerdown', ()=>{ if(gameState==='playing') turtle.jump(); }, {passive:true});

    // ===== Run lifecycle =====
    function startRun(now){
      obstacles.length=0; spawnTimer=0; score=0; updateScore(); hearts=maxHearts; cleanJumps=0;
      startSpeed = baseSpeed * (W()/900); minSpeed = startSpeed*0.5; maxSpeed = startSpeed*2.0; speed=startSpeed;
      laneDist[0]=laneDist[1]=laneDist[2]=0; nbDist=fenceDist=dashDist=0; crashedFlashTimer=0;
      reseed();
      heartPickups.length=0; heartSpawnTimer=0; scheduleNextHeart();
      coinPickups.length=0; coinSpawnTimer=0; scheduleNextCoin();
      floaters.length=0;
      last=now;
    }

    function triggerGameOver(){ gameState='gameover'; finalScoreEl.textContent=String(score); gameOverEl.style.display='grid'; }

    // ===== Collision helpers =====
    function roundRect(ctx,x,y,w,h,r,fill){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); if(fill) ctx.fill(); else ctx.stroke(); }
    function aabb(ax,ay,aw,ah,bx,by,bw,bh){ return !(ax+aw<=bx || ax>=bx+bw || ay+ah<=by || ay>=by+bh); }
    function turtleAABB(){ const x=turtle.x(), y=groundY()-turtle.r()*1.2 - turtle.y; const r=turtle.r(); return {x:x-r*0.9, y:y-r*0.9, w:r*1.8, h:r*1.8}; }
    function collides(o){ const t=turtleAABB(); return aabb(t.x,t.y,t.w,t.h,o.x,o.y,o.w,o.h); }

    // Find safe X for pickup (avoid overlapping any obstacle)
    function findClearX(initX, y, w, h){ let x=initX; const marginX=Math.max(W()*0.08, w*2); for(let tries=0; tries<8; tries++){ let blocked=false, nextX=x; for(const o of obstacles){ const ox=o.x-marginX*0.5, oy=o.y, ow=o.w+marginX, oh=o.h; if(aabb(x,y,w,h,ox,oy,ow,oh)){ nextX=Math.max(nextX, o.x+o.w+marginX); blocked=true; } } if(!blocked) return x; x=nextX; if(x>W()*3) break; } return null; }

    // ===== Spawning =====
    function spawnObstacle(){
      const type = rng()<0.55 ? OBST.BOX : OBST.CAR;
      const gap = (W()*0.25) + rng()*W()*0.35; // spacing from previous
      const x = (obstacles.length? obstacles[obstacles.length-1].x : W()) + gap;
      if(type===OBST.CAR){
        const sizeBase = (H()*0.06 + rng()*H()*0.04);
        const hMul = 0.9 + rng()*0.35; const wMul = 1.9 + rng()*0.6;
        const h = sizeBase*hMul, w = sizeBase*wMul, y = groundY()-h;
        const palette=['#e35252','#2196f3','#2ecc71','#f4b400','#9c27b0','#ff9800','#00bcd4','#ff6f61','#95a5a6'];
        const body=palette[(rng()*palette.length)|0];
        const wheelStyles=['solid','spokes','whitewall','dots']; const wheelStyle=wheelStyles[(rng()*wheelStyles.length)|0];
        const rimColor = rng()<0.5?'#d9d9d9':'#222222';
        const stripe = rng()<0.35; const tint = 0.18 + rng()*0.35;
        obstacles.push({type,x,y,w,h,scored:false,hit:false,v:{body,wheelStyle,rimColor,stripe,tint}});
      } else {
        // Cardboard box variants
        const base=(H()*0.05 + rng()*H()*0.03);
        const stacked=rng()<0.22; const wMul=0.9 + rng()*0.7; const hMul= stacked?1.6:(0.85 + rng()*0.7);
        const tilt= stacked?0: (rng()-0.5)*0.18; const shade=(rng()*3)|0;
        const stickerPool=['none','fragile','up','logo']; const sticker=stickerPool[(rng()*stickerPool.length)|0];
        const tapeStyle = rng()<0.5?'center':'band';
        const h=base*hMul, w=base*wMul*1.1, y=groundY()-h;
        obstacles.push({type,x,y,w,h,scored:false,hit:false,v:{stacked,tilt,shade,sticker,tapeStyle}});
      }
      nextSpawnIn = 240 + rng()*380;
    }

    function spawnHeart(){ if(hearts>=maxHearts) return; const size=H()*0.09; const y=groundY()-size - H()*0.05; const baseX=(obstacles.length? Math.max(W()+W()*0.1, obstacles[obstacles.length-1].x + W()*0.3): W()+W()*0.2); const x=findClearX(baseX,y,size,size); if(x==null) return; heartPickups.push({x,y,w:size,h:size,born:performance.now(),collected:false}); }
    function spawnCoin(){ const size=H()*(0.065 + rng()*0.02); const y=groundY()-size - H()*0.18; const baseX=(obstacles.length? Math.max(W()+W()*0.1, obstacles[obstacles.length-1].x + W()*0.35): W()+W()*0.25); const x=findClearX(baseX,y,size,size); if(x==null) return; coinPickups.push({x,y,w:size,h:size,born:performance.now(),collected:false}); }

    // ===== Drawing =====
    function drawBackground(now){
      if(!tClockStart) tClockStart=now; const t=now - tClockStart; const phase=(t%DAY_NIGHT_PERIOD)/DAY_NIGHT_PERIOD; const light = 0.5*(1+Math.cos(phase*Math.PI*2));
      // Sky
      const sky = mixColor('#0a2540','#a8d8ff', light);
      ctx.fillStyle=sky; ctx.fillRect(0,0,W(),H());
      // Sun/Moon
      const orbY = lerp(H()*0.8, H()*0.18, light), orbX = lerp(W()*0.9, W()*0.1, light), orbR=H()*0.07;
      ctx.fillStyle = light>0.5? '#ffd36b':'#dbe7ff'; ctx.beginPath(); ctx.arc(snap(orbX),snap(orbY),orbR,0,Math.PI*2); ctx.fill();
      // Stars
      if(light<0.55){ ctx.fillStyle='rgba(255,255,255,'+(0.4*(0.55-light)/0.55).toFixed(3)+')'; for(let i=0;i<40;i++){ const sx=snap(i*97%W()); const sy=snap(i*53%(groundY()-40)); ctx.fillRect(sx,sy,2*DPR,2*DPR);} }

      // Skyscraper layers
      const cDay=['#6aa0c9','#4e8bb9','#3e78a7'], cNight=['#2a4c66','#23435a','#1b394e'];
      const lanes=[{h:0.5},{h:0.6},{h:0.7}];
      lanes.forEach((L,i)=>{
        const yTop = H()*(1-L.h)-roadH()*0.2; const bw=Math.round(W()*0.11); const gap=Math.round(W()*0.035); const seg=bw+gap;
        const total=laneDist[i]; const baseIndex=Math.floor(total/seg); const frac=total-baseIndex*seg; const startX=-frac;
        const facadeColor = mixColor(cNight[i], cDay[i], light); // smooth blend
        const night = 1-light; const tlin=Math.max(0, Math.min(1, (night-0.25)/0.45)); const nightMix = tlin*tlin*(3-2*tlin);
        const dayHex='#1b1b1b', nightHex='#ffd36b';
        for(let k=-1,x=startX-seg; x<W()+seg; x+=seg, k++){
          const dx=snap(x); const bId=baseIndex+k+i*1000; const shapeNoise=hash(bId*37.1337); const bH=H()*L.h*(0.72+(i===0?0.12:0.18)*shapeNoise); const bW=bw; const bTop=snap(yTop + (H()*L.h - bH)); const bLeft=dx; const bHeight=Math.round(bH);
          ctx.fillStyle=facadeColor; ctx.fillRect(bLeft,bTop,bW,bHeight);
          // windows sparse & stable
          const padX=10, padTop=8, padBottom=10, winW=8, winH=10, rowGap=16; const innerW=bW-padX*2; const rows=Math.max(0, Math.floor((bHeight-padTop-padBottom-winH)/rowGap)+1);
          for(let row=0; row<rows; row++){
            const rowSeed=hash(bId*911 + row*131); const n=Math.floor(rowSeed*3); if(n===0) continue;
            for(let j=0;j<n;j++){
              const slotCenter=bLeft+padX + innerW*(j+1)/(n+1); const wx=snap(slotCenter-winW/2); const wy=snap(bTop+padTop+row*rowGap);
              const lit = hash(bId*1723 + row*47 + j*13) < 0.5; const color = lit? mixColor(dayHex, nightHex, nightMix): dayHex; ctx.fillStyle=color; ctx.fillRect(wx,wy,winW,winH);
            }
          }
        }
      });

      // Neighborhood (trees & houses)
      const nbBaseY=groundY(); const itemW=W()*0.12, itemGap=W()*0.04, nSeg=itemW+itemGap; const nbBaseIndex=Math.floor(nbDist/nSeg); const nbFrac=nbDist-nbBaseIndex*nSeg;
      const trunkColor=mixColor('#4a301a','#7b4f2a',light), canopyColor=mixColor('#1e5f29','#2e8f3a',light), houseBodyColor=mixColor('#6c7a96','#d9e4ff',light), roofColor=mixColor('#7a2d22','#c04f3b',light), accentColor=mixColor('#3a4a64','#8aa2cc',light);
      for(let i=-1,x=-nbFrac-nSeg; x<W()+nSeg; x+=nSeg,i++){
        const tileIdx=nbBaseIndex+i, dx=snap(x), r=hash(tileIdx+1);
        if(r<0.55){
          const tH=H()*(0.16+hash(tileIdx+2)*0.07), trunkW=Math.max(4*DPR, tH*0.08), trunkH=tH*0.55, baseX=dx+itemW*0.5; // tree
          ctx.fillStyle=trunkColor; ctx.fillRect(snap(baseX-trunkW/2), snap(nbBaseY-trunkH), trunkW, trunkH);
          const canopyR=tH*0.35; ctx.fillStyle=canopyColor; ctx.beginPath(); ctx.arc(snap(baseX-canopyR*0.4), snap(nbBaseY-trunkH), canopyR,0,Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(snap(baseX+canopyR*0.4), snap(nbBaseY-trunkH+canopyR*0.2), canopyR*0.9,0,Math.PI*2); ctx.fill();
        } else {
          const w=itemW*(0.9-hash(tileIdx+3)*0.25), h=H()*(0.16+hash(tileIdx+4)*0.12), hx=dx+(itemW-w)/2, hy=nbBaseY-h; // house
          ctx.fillStyle=houseBodyColor; ctx.fillRect(snap(hx),snap(hy),snap(w),snap(h));
          ctx.fillStyle=roofColor; ctx.beginPath(); ctx.moveTo(snap(hx-6),snap(hy)); ctx.lineTo(snap(hx+w/2),snap(hy-h*0.45)); ctx.lineTo(snap(hx+w+6),snap(hy)); ctx.closePath(); ctx.fill();
          ctx.fillStyle=accentColor; const doorW=Math.max(10*DPR, w*0.14), doorH=h*0.4; ctx.fillRect(snap(hx+w*0.12), snap(hy+h-doorH), snap(doorW), snap(doorH));
          for(let wx=0;wx<2;wx++){ ctx.fillRect(snap(hx+w*0.55+wx*(doorW+8)), snap(hy+h*0.3), snap(doorW), snap(doorW)); }
        }
      }

      // Fence
      const fenceColor=mixColor('#8f7a5f','#bfa98a',light), fenceSegW=W()*0.08, fenceGap=W()*0.02, fSeg=fenceSegW+fenceGap, fenceY=groundY(); const fBaseIndex=Math.floor(fenceDist/fSeg), fFrac=fenceDist-fBaseIndex*fSeg;
      for(let i=-1,x=-fFrac-fSeg; x<W()+fSeg; x+=fSeg,i++){
        const fx=snap(x); for(let px=0; px<=3; px++){ const postX=snap(fx + px*(fenceSegW/3)); ctx.beginPath(); ctx.moveTo(postX, snap(fenceY)); ctx.lineTo(postX, snap(fenceY-18*DPR)); ctx.strokeStyle=fenceColor; ctx.lineWidth=3*DPR; ctx.stroke(); }
        ctx.beginPath(); ctx.strokeStyle=fenceColor; ctx.lineWidth=3*DPR; ctx.moveTo(snap(fx-2), snap(fenceY-6*DPR)); ctx.lineTo(snap(fx+fenceSegW+2), snap(fenceY-6*DPR)); ctx.moveTo(snap(fx-2), snap(fenceY-12*DPR)); ctx.lineTo(snap(fx+fenceSegW+2), snap(fenceY-12*DPR)); ctx.stroke();
      }

      // Road & dashes
      ctx.fillStyle='#333'; ctx.fillRect(0,groundY(),W(),roadH());
      const dashW=W()*0.08, dashH=6*DPR, dashGap=W()*0.06, dSeg=dashW+dashGap, dFrac=dashDist%dSeg; ctx.fillStyle= light>0.5? '#f5f5a5':'#bcb88a';
      for(let x=-dFrac-dSeg; x<W()+dashW; x+=dSeg){ ctx.fillRect(snap(x), groundY()+roadH()*0.35, dashW, dashH); }
      return light;
    }

    function drawHeartIcon(cx,cy,s,filled){ ctx.beginPath(); ctx.moveTo(cx, cy+s*0.9); ctx.bezierCurveTo(cx-s*1.6, cy-s*0.1, cx-s*0.9, cy-s*1.2, cx, cy-s*0.4); ctx.bezierCurveTo(cx+s*0.9, cy-s*1.2, cx+s*1.6, cy-s*0.1, cx, cy+s*0.9); ctx.closePath(); if(filled){ ctx.fillStyle='#e74c3c'; ctx.fill(); ctx.strokeStyle='#8c1f1f'; ctx.lineWidth=1.5*DPR; ctx.stroke(); } else { ctx.strokeStyle='#8c1f1f'; ctx.lineWidth=1.5*DPR; ctx.stroke(); } }

    function drawHeartPickup(p,now){ const t=now-p.born; const bob=Math.sin(t/600)*(p.h*0.22); const s=(p.h*0.33)*(1+0.10*Math.sin(t/280)); const cx=p.x+p.w/2, cy=p.y+p.h/2 + bob; ctx.fillStyle='rgba(231,76,60,0.25)'; ctx.beginPath(); ctx.arc(cx, cy, p.h*0.55, 0, Math.PI*2); ctx.fill(); drawHeartIcon(cx,cy,s,true); }
    function drawCoinPickup(p,now){ const t=now-p.born; const bob=Math.sin(t/600)*(p.h*0.22); const cx=p.x+p.w/2, cy=p.y+p.h/2 + bob; const r=p.h*0.45; ctx.fillStyle='rgba(255,215,0,0.22)'; ctx.beginPath(); ctx.arc(cx,cy,r*1.35,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#f0c419'; ctx.beginPath(); ctx.arc(cx,cy,r,0,Math.PI*2); ctx.fill(); ctx.strokeStyle='#b88700'; ctx.lineWidth=Math.max(2*DPR, r*0.18); ctx.beginPath(); ctx.arc(cx,cy,r*0.78,0,Math.PI*2); ctx.stroke(); ctx.save(); ctx.translate(cx,cy); ctx.rotate(t/700); ctx.strokeStyle='rgba(255,255,255,0.85)'; ctx.lineWidth=1.5*DPR; ctx.beginPath(); ctx.moveTo(-r*0.15,0); ctx.lineTo(r*0.15,0); ctx.moveTo(0,-r*0.15); ctx.lineTo(0,r*0.15); ctx.stroke(); ctx.restore(); }

    function drawTurtle(now, light){
      const x=turtle.x(), y=groundY()-turtle.r()*1.2 - turtle.y, r=turtle.r();
      // shadow
      ctx.fillStyle='rgba(0,0,0,0.18)'; const sw=r*1.6, sh=r*0.55, sy=groundY()-sh*0.5; ctx.beginPath(); ctx.ellipse(snap(x), snap(sy), sw*0.5, sh*0.5, 0, 0, Math.PI*2); ctx.fill();
      // shell
      ctx.fillStyle='#2f8f2f'; ctx.beginPath(); ctx.ellipse(snap(x), snap(y), r*1.1, r*0.9, 0, 0, Math.PI*2); ctx.fill();
      ctx.strokeStyle='#1f681f'; ctx.lineWidth=3*DPR; for(let i=0;i<6;i++){ const a=i*Math.PI/3 + ((now-tClockStart)*0.005); ctx.beginPath(); ctx.arc(snap(x), snap(y), r*0.6, a, a+0.8); ctx.stroke(); }
      // head
      ctx.fillStyle='#49a84a'; ctx.beginPath(); ctx.ellipse(snap(x + r*1.05), snap(y - r*0.2), r*0.55, r*0.45, 0, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle='#111'; ctx.beginPath(); ctx.arc(snap(x + r*1.35), snap(y - r*0.25), r*0.12, 0, Math.PI*2); ctx.fill();
      // legs + skates
      const legY=y + r*0.7; const phase=(now-tClockStart)*0.01 * (speed||startSpeed) * 4; const stride=Math.sin(phase)*r*0.12; const legs=[-r*0.6,-r*0.1,r*0.2,r*0.65];
      ctx.fillStyle='#49a84a'; legs.forEach((lx,i)=>{ const ly=legY + (i%2===0? stride:-stride); ctx.fillRect(snap(x + lx - r*0.12), snap(ly), r*0.24, r*0.22); const skateW=r*0.34, skateH=r*0.12; ctx.fillStyle='#4ea2ff'; ctx.fillRect(snap(x + lx - skateW/2), snap(ly + r*0.22), skateW, skateH); ctx.fillStyle='#111'; const wheels=2, gap=skateW/wheels; for(let w=0; w<wheels; w++){ ctx.beginPath(); ctx.arc(snap(x + lx - skateW/2 + gap*(w+0.5)), snap(ly + r*0.22 + skateH + r*0.04), r*0.07, 0, Math.PI*2); ctx.fill(); } ctx.fillStyle='#49a84a'; });
    }

    function drawFloaters(now){
      const duration = 900; // ms
      ctx.save();
      ctx.font = `${14*DPR}px system-ui, sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'bottom';
      const keep = [];
      for (const f of floaters) {
        const t = now - f.born;
        if (t >= duration) continue;
        const p = Math.max(0, Math.min(1, t / duration));
        const y = f.y - p * 28 * DPR;
        ctx.globalAlpha = 1 - p;
        // subtle outline for legibility
        ctx.strokeStyle = 'rgba(255,255,255,0.9)';
        ctx.lineWidth = 3*DPR;
        ctx.strokeText(f.text, f.x, y);
        ctx.fillStyle = '#063';
        ctx.fillText(f.text, f.x, y);
        keep.push(f);
      }
      ctx.restore();
      floaters = keep;
    }

    function drawObstacle(o){
      if(o.type===OBST.BOX){
        const x=o.x,y=o.y,w=o.w,h=o.h,v=o.v||{stacked:false,tilt:0,shade:1,sticker:'none',tapeStyle:'center'}; const kraft=['#c79d62','#b88a52','#a67945']; const shadow=['#9a7647','#8a6b41','#755835'][v.shade||0]; const body = kraft[v.shade||0]; const tape=v.tapeStyle==='band'? '#e8d8aa':'#ead7a4';
        function single(px,py,pw,ph,tilt){ const flapH=ph*0.18, r=4*DPR; ctx.save(); const cx=px+pw/2, cy=py+ph/2; ctx.translate(cx,cy); ctx.rotate(tilt); ctx.translate(-cx,-cy); ctx.fillStyle=body; roundRect(ctx,px,py+flapH,pw,ph-flapH,r,true); ctx.fillStyle=body; ctx.beginPath(); ctx.moveTo(snap(px),snap(py+flapH)); ctx.lineTo(snap(px+pw*0.5),snap(py)); ctx.lineTo(snap(px+pw*0.5),snap(py+flapH)); ctx.closePath(); ctx.fill(); ctx.beginPath(); ctx.moveTo(snap(px+pw),snap(py+flapH)); ctx.lineTo(snap(px+pw*0.5),snap(py)); ctx.lineTo(snap(px+pw*0.5),snap(py+flapH)); ctx.closePath(); ctx.fill(); ctx.strokeStyle=shadow; ctx.lineWidth=2*DPR; ctx.beginPath(); ctx.moveTo(snap(px+pw*0.5),snap(py)); ctx.lineTo(snap(px+pw*0.5),snap(py+flapH+ph*0.05)); ctx.stroke(); if(v.tapeStyle==='band'){ ctx.fillStyle=tape; ctx.fillRect(snap(px+pw*0.12), snap(py+flapH+ph*0.06), snap(pw*0.76), snap(ph*0.08)); } else { ctx.fillStyle=tape; ctx.fillRect(snap(px+pw*0.485), snap(py), snap(pw*0.03), snap(flapH)); } if(v.sticker==='fragile'){ ctx.fillStyle='#6b3a2a'; ctx.font=`${Math.max(10*DPR, ph*0.12)}px system-ui`; ctx.fillText('FRAGILE', snap(px+pw*0.12), snap(py+flapH+ph*0.35)); } else if(v.sticker==='up'){ ctx.strokeStyle='#6b3a2a'; const ax=px+pw*0.78, ay=py+flapH+ph*0.15, ah=ph*0.22, aw=pw*0.06; ctx.beginPath(); ctx.moveTo(snap(ax),snap(ay+ah)); ctx.lineTo(snap(ax),snap(ay)); ctx.lineTo(snap(ax-aw/2),snap(ay+aw)); ctx.moveTo(snap(ax),snap(ay)); ctx.lineTo(snap(ax+aw/2),snap(ay+aw)); ctx.moveTo(snap(ax+aw*1.8),snap(ay+ah)); ctx.lineTo(snap(ax+aw*1.8),snap(ay)); ctx.lineTo(snap(ax+aw*1.8-aw/2),snap(ay+aw)); ctx.moveTo(snap(ax+aw*1.8),snap(ay)); ctx.lineTo(snap(ax+aw*1.8+aw/2),snap(ay+aw)); ctx.stroke(); } else if(v.sticker==='logo'){ ctx.fillStyle='#6b3a2a'; roundRect(ctx, px+pw*0.1, py+flapH+ph*0.18, pw*0.22, ph*0.16, 3*DPR, true); } ctx.restore(); }
        if(v.stacked){ const gap=h*0.06, hTop=h*0.42, hBot=h*0.52, yBot=y+h-hBot, yTop=yBot-gap-hTop, wTop=w*0.9; single(x+(w-w)*0.5, yBot, w, hBot, 0); single(x+(w-wTop)*0.5, yTop, wTop, hTop, 0); } else { single(x,y,w,h,v.tilt||0); }
      } else { // CAR
        const x=o.x,y=o.y,w=o.w,h=o.h,v=o.v||{body:'#e35252',wheelStyle:'solid',rimColor:'#d9d9d9',stripe:false,tint:0.3}; const r=8*DPR; const bodyDark=mixColor(v.body,'#000000',0.35);
        ctx.fillStyle=v.body; roundRect(ctx, x, y+h*0.25, w, h*0.75, r, true); ctx.fillStyle=bodyDark; roundRect(ctx, x+w*0.12, y+h*0.02, w*0.52, h*0.38, r*0.8, true);
        ctx.fillStyle=`rgba(230,245,255,${Math.max(0.15, Math.min(0.75, v.tint))})`; ctx.fillRect(x+w*0.16, y+h*0.08, w*0.38, h*0.22);
        if(v.stripe){ const stripeCol=mixColor(v.body,'#ffffff',0.5); ctx.fillStyle=stripeCol; ctx.fillRect(x+w*0.08, y+h*0.55, w*0.84, h*0.08); }
        function wheel(cx,cy,rad,style){ ctx.fillStyle='#111'; ctx.beginPath(); ctx.arc(cx,cy,rad,0,Math.PI*2); ctx.fill(); if(style==='whitewall'){ ctx.strokeStyle='#fff'; ctx.lineWidth=rad*0.35; ctx.beginPath(); ctx.arc(cx,cy,rad*0.78,0,Math.PI*2); ctx.stroke(); } ctx.fillStyle=v.rimColor; ctx.beginPath(); ctx.arc(cx,cy,rad*0.55,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#333'; ctx.beginPath(); ctx.arc(cx,cy,rad*0.22,0,Math.PI*2); ctx.fill(); if(style==='spokes'){ ctx.strokeStyle='#ccc'; ctx.lineWidth=Math.max(1,DPR); for(let a=0;a<Math.PI*2;a+=Math.PI/5){ ctx.beginPath(); ctx.moveTo(cx,cy); ctx.lineTo(cx+Math.cos(a)*rad*0.5, cy+Math.sin(a)*rad*0.5); ctx.stroke(); } } else if(style==='dots'){ ctx.fillStyle='#bbb'; for(let a=0;a<Math.PI*2;a+=Math.PI/6){ ctx.beginPath(); ctx.arc(cx+Math.cos(a)*rad*0.42, cy+Math.sin(a)*rad*0.42, rad*0.06, 0, Math.PI*2); ctx.fill(); } } }
        const wheelY=y+h*0.95, rad=h*0.18; wheel(x+w*0.25, wheelY, rad, v.wheelStyle); wheel(x+w*0.75, wheelY, rad, v.wheelStyle); ctx.fillStyle='#ffd36b'; ctx.fillRect(x+w*0.92, y+h*0.5, h*0.15, h*0.12);
      }
    }

    function drawHUD(){ if(gameState!=='playing') return; // hearts top-right
      const pad=12*DPR, s=9*DPR, gap=22*DPR, x0=canvas.width - pad - (maxHearts-1)*gap, y=22*DPR; for(let i=0;i<maxHearts;i++){ const cx=x0+i*gap; drawHeartIcon(cx,y,s, i<hearts); }
      const awardNow = cleanJumps>0 ? Math.min(5, Math.floor((cleanJumps-1)/3)+1) : 1;
      // Fade logic for multiplier pill
      if (awardNow > 1) {
        if (multTierVis !== awardNow) {
          multTierVis = awardNow;
          multAlphaTarget = 1;               // ensure we fade in on change
          multAlpha = Math.min(multAlpha, 0.15); // quick pop on tier change
        } else {
          multAlphaTarget = 1;               // stay visible while active
        }
      } else {
        multAlphaTarget = 0;                 // fade out when inactive
      }
      // ease alpha toward target
      multAlpha += (multAlphaTarget - multAlpha) * 0.15;

      // Score pill (center-top)
      ctx.save();
      ctx.font = `${16*DPR}px system-ui, sans-serif`;
      ctx.textBaseline = 'top';
      const padX = 7*DPR, padY = 6*DPR;
      const scoreLabel = `Score: ${score}`;
      const scoreTextW = ctx.measureText(scoreLabel).width;
      const scoreBoxW = Math.round(scoreTextW + padX*2);
      const scoreBoxH = Math.round(24*DPR);
      const sbx = Math.round((canvas.width - scoreBoxW)/2);
      const sby = Math.round(12*DPR);
      ctx.fillStyle = 'rgba(255,255,255,0.78)';
      roundRect(ctx, sbx, sby, scoreBoxW, scoreBoxH, 10*DPR, true);
      ctx.fillStyle = '#063';
      ctx.fillText(scoreLabel, sbx + padX, sby + padY);

      // Multiplier pill (to the right of score, with fade)
      if (multAlpha > 0.02) {
        const multLabel = `Multiplier ×${multTierVis}`;
        const mTextW = ctx.measureText(multLabel).width;
        const mBoxW = Math.round(mTextW + padX*2);
        const mBoxH = scoreBoxH;
        const gapX = 8*DPR;
        let mbx = sbx + scoreBoxW + gapX;
        const mby = sby;
        if (mbx + mBoxW > canvas.width - 12*DPR) mbx = canvas.width - 12*DPR - mBoxW;
        ctx.save();
        ctx.globalAlpha = Math.max(0, Math.min(1, multAlpha));
        ctx.fillStyle = 'rgba(255,255,255,0.78)';
        roundRect(ctx, mbx, mby, mBoxW, mBoxH, 10*DPR, true);
        ctx.fillStyle = '#063';
        ctx.fillText(multLabel, mbx + padX, mby + padY);
        ctx.restore();
      }
      ctx.restore(); ctx.fillStyle='#063'; ctx.font=`${14*DPR}px system-ui, sans-serif`; const pct=((speed-minSpeed)/(maxSpeed-minSpeed)*100).toFixed(0); ctx.fillText(`speed: ${(speed*60).toFixed(1)}  (${pct}% of range)`, 12*DPR, 20*DPR); }

    // ===== Update loop =====
    function update(dt){
      // background scroll always advances light/time; geometry scroll only when playing
      if(gameState!=='playing'){ crashedFlashTimer=Math.max(0, crashedFlashTimer-dt); return; }
      // Spawn obstacles
      spawnTimer += dt; if(obstacles.length===0 || spawnTimer > nextSpawnIn){ spawnObstacle(); spawnTimer=0; }
      const vx = speed * dt * 1.0;
      // Obstacles move & scoring
      for (const o of obstacles) {
        const prevRight = o.x + o.w;
        o.x -= vx;

        if (!o.hit && collides(o)) {
          o.hit = true;
          crashedFlashTimer = 180;
          speed = clampSpeed(speed - startSpeed * 0.08);
          hearts = Math.max(0, hearts - 1);
          cleanJumps = 0; // reset combo on damage
          if (hearts === 0) { triggerGameOver(); break; }
          if (score > 0) { score--; updateScore(); }
        }

        const cross = (prevRight >= turtle.x()) && ((o.x + o.w) < turtle.x());
        if (cross && !o.scored) {
          const airborne = turtle.y > turtle.r() * 0.18;
          if (airborne && !o.hit) {
            cleanJumps++;
            const award = Math.min(5, Math.floor((cleanJumps - 1) / 3) + 1);
            score += award; updateScore();
            // floating +X over turtle
            floaters.push({ text: `+${award}`, x: turtle.x(), y: groundY()-turtle.r()*1.2 - turtle.y - 12*DPR, born: performance.now(), ttl: 900 });
            // speed up only on clean jump
            speed = clampSpeed(speed + startSpeed * 0.02);
          }
          o.scored = true;
        }
      }
      obstacles = obstacles.filter(o => o.x + o.w > -W()*0.15);
      // Pickups — hearts
      if(hearts < maxHearts){ heartSpawnTimer += dt; if(heartPickups.length===0 && heartSpawnTimer>=nextHeartIn){ spawnHeart(); heartSpawnTimer=0; scheduleNextHeart(); } } else { heartSpawnTimer=0; }
      for(const h of heartPickups){ h.x -= vx; if(collides(h)){ hearts=Math.min(maxHearts, hearts+1); h.collected=true; } }
      heartPickups = heartPickups.filter(h=>!h.collected && (h.x+h.w > -W()*0.15));
      // Pickups — coins
      coinSpawnTimer += dt; if(coinPickups.length===0 && coinSpawnTimer>=nextCoinIn){ spawnCoin(); coinSpawnTimer=0; scheduleNextCoin(); }
      for(const c of coinPickups){ c.x -= vx; if(collides(c)){ score++; updateScore(); c.collected=true; } }
      coinPickups = coinPickups.filter(c=>!c.collected && (c.x+c.w > -W()*0.15));
      // Turtle physics
      const g=0.0020*H(); turtle.vy -= g*dt/16.666; turtle.y += turtle.vy*dt/16.666; if(turtle.y<=0){ turtle.y=0; turtle.vy=0; turtle.onGround=true; } else { turtle.onGround=false; }
      // Scroll distances
      const ds = speed*dt; laneDist[0]+=ds*0.20; laneDist[1]+=ds*0.35; laneDist[2]+=ds*0.50; nbDist+=ds*0.85; fenceDist+=ds*1.10; dashDist+=ds*1.50; for(let i=0;i<3;i++) if(laneDist[i]>1e7) laneDist[i]%=1000; if(nbDist>1e7) nbDist%=1000; if(fenceDist>1e7) fenceDist%=1000; if(dashDist>1e7) dashDist%=1000;
      crashedFlashTimer=Math.max(0, crashedFlashTimer-dt);
    }

    // ===== Main draw loop =====
    function draw(now){ if(!tClockStart) tClockStart=now; const dt=Math.min(32, now-(last||now)); last=now; update(dt); const light=drawBackground(now); for(const o of obstacles) drawObstacle(o); for(const hp of heartPickups) drawHeartPickup(hp, now); for(const cp of coinPickups) drawCoinPickup(cp, now); drawTurtle(now, light);
      drawFloaters(now);
      if(crashedFlashTimer>0){ ctx.fillStyle='rgba(255,50,50,0.22)'; ctx.fillRect(0,0,W(),H()); } drawHUD(); requestAnimationFrame(draw); }

    // Kick off
    requestAnimationFrame(draw);
  })();
  </script>
</body>
</html>
